# Задание A1 Максимов Никита БПИ 227-1
## [Код прогрaммы](main.py)
```python
import math
import random as rnd
import pandas as pd
import matplotlib.pyplot as plt


def randomXY():
    x = rnd.uniform(-1, 1)
    y = rnd.uniform(-1, 1)
    return x, y


def monteCarlo(n):
    M = 0
    for i in range(n):
        x, y = randomXY()
        if (x ** 2 + y ** 2) <= 1:
            M += 1
    pi = 4 * (M / n)
    return pi


arr = []
num = []
sigma = []
for N in range(100, 5100, 100):
    x = monteCarlo(N)
    pi = math.pi
    arr.append(x)
    num.append(N)
    sigma.append((abs(x-pi)/ pi)) * 100)

plt.subplot(1, 3, 1)
plt.plot(num, arr, marker='o', markersize=5)
plt.hlines(math.pi, 0, 5000, color='red')
plt.xlabel("Кол-во испытаний")
plt.ylabel("Значение ПИ")
plt.title("График №1")

plt.subplot(1, 3, 3)
plt.plot(num, sigma, marker='o', markersize=5)
plt.hlines(0, 0, 5000, color='blue')
plt.xlabel("Кол-во испытаний")
plt.ylabel("Отклонение в %")
plt.title("График №2")
data = pd.DataFrame({'Кол-во испытаний': num, 'Значение PI': arr, 'Отклонение в процентах': sigma})
print(data)
plt.show()
```
## Выводы и результаты

![Результаты](https://github.com/waksimusss/Searching-Pi-with-Monte_Carlo/assets/113054845/9dcfa890-4d79-4cf4-bef3-f1d8fc3b72ae)

|Кол-во испытаний|  Значение PI | Отклонение в процентах|
| --- | --- | --- |
| 100 | 3.160000 | 0.585924|
| 200 | 3.440000 | 9.498601|
| 300 |3.266667 | 3.981229|
| 400 | 3.220000 | 2.495783|
| 500 | 3.104000 | 1.196611|
| 600 | 3.100000 | 1.323935|
| 700 | 3.165714 | 0.767815|
| 800 | 3.090000 | 1.642245|
| 900 | 3.142222 | 0.020040|
| 1000 |3.008000 | 4.252386|
| 1100 |3.160000 | 0.585924|
| 1200 | 3.210000 | 2.177473|
| 1300 | 3.092308 | 1.568789|
| 1400 | 3.128571 | 0.414478|
| 1500 | 3.144000 | 0.076628|
| 1600 | 3.145000 | 0.108459|
| 1700 | 3.195294 | 1.709371|
| 1800 |  3.095556 | 1.465406|
| 1900 | 3.151579 | 0.317874|
| 2000 | 3.116000 | 0.814639|
| 2100   | 3.139048         |       0.081011|
| 2200  |   3.087273    |            1.729057|
| 2300|     3.206957     |           2.080597|
| 2400 |    3.151667    |            0.320666|
| 2500|     3.147200       |         0.178487|
| 2600 |   3.136923   |            0.148637|
| 2700 |   3.247407       |        3.368188|
| 2800    | 3.194286 |               1.677272|
| 2900  |   3.132414     |           0.292172|
| 3000  |   3.076000           |     2.087879|
| 3100  |   3.122581        |       0.605171|
| 3200  |   3.172500         |       0.983811|
| 3300  |   3.155152         |       0.431592|
| 3400   |  3.140000           |     0.050696|
| 3500    | 3.126857                |0.469046|
| 3600    | 3.176667                |1.116441|
| 3700  |   3.154595              |  0.413865|
|          3800  |   3.116842              |  0.787834|
|          3900   |  3.175385             |   1.075632|
|         4000   |  3.172000            |    0.967896|
|         4100  |   3.200976           |     1.890218|
|         4200   |  3.178095            |    1.161913|
|           4300  |   3.120000           |     0.6873163|              
|          4400    | 3.167273          |      0.817422|
|           4500   |  3.084444         |       1.819084|
|           4600   |  3.141739        |        0.004663|
|           4700   |  3.187234       |         1.452811|
|           4800   |  3.142500        |        0.028882|
|           4900  |   3.113469       |         0.895191|
|           5000   |  3.135200       |         0.203484|

Перед расуждениями, стоит отметить, что данные кадждый раз получаются новыми, все-таки точки генерируются каждый раз случайным образом. Я привел пример получившихся результатов после выполнения программы. На их основе сделаем общие выводы. Как можно заметить, с увеличение кол-ва испытаний стретимиться к максимально точному числу. При этом не обходится и без выбросов даже на большом кол-во испытаний, просто многие точки попадают не в окуржность, но шанс этого все уменьшается и уменьшается при увеличнении кол-во тестов. Это можно проверить, запустив программу с очень болшим N. 
> Я изменил цикл и проходился от 100 до 200000 с шагом в 10000.

![Результаты с больши N](https://github.com/waksimusss/Searching-Pi-with-Monte_Carlo/assets/113054845/bea0f3e8-3f05-45f9-834b-c2b22fd24e8c)


Общий вывод можно сформулировать след. образом: Алгоритм Монте-Карло, помогает вычислить значение числа пи, но нужно быть внимательным к выбросам. Для получения более точных значений нужно увеличивать значение испытаний. Если бы кол-во испытаний было бесконечным, то мы бы получили число пи, которое, к сожалению, было бы ограничено по числу знаков, так как память компьютера не может хранить иррациональные числа.
